var ArgumentError, DEFAULT_OPTIONS, Property, PropertyFilter, readLine, through, _;

_ = require('underscore');

Property = require('./property');

ArgumentError = require('common-errors').ArgumentError;

through = require('through2');


/* Defaults */

DEFAULT_OPTIONS = {
  delimiters: ['${*}', '@']
};

readLine = function() {
  var buffer;
  buffer = '';
  return through.obj(function(chunk, enc, cb) {
    var idx, line;
    buffer += chunk;
    idx = buffer.indexOf("\n");
    while (idx > -1) {
      idx++;
      line = buffer.substring(0, idx);
      buffer = buffer.substring(idx);
      idx = buffer.indexOf("\n");
      this.push(line);
    }
    return cb();
  }, function(cb) {
    this.push(buffer);
    return cb();
  });
};

PropertyFilter = (function() {
  function PropertyFilter(options) {
    options || (options = {});
    this.properties = options.properties;
    this.delimiters = options.delimiters || DEFAULT_OPTIONS.delimiters;
    if (!_.isArray(this.delimiters)) {
      this.delimiters = [this.delimiters];
    }
  }

  PropertyFilter.prototype.filterString = function(string) {
    _.each(this.properties, (function(_this) {
      return function(property) {
        return _.each(_this.delimiters, function(delimeter) {
          return string = property.filterString(string, delimeter);
        });
      };
    })(this));
    return string;
  };

  PropertyFilter.prototype.filterStream = function(inStream) {
    var filter, filterTransform;
    filter = this;
    filterTransform = through.obj(function(line, enc, cb) {
      this.push(filter.filterString(line));
      return cb();
    });
    return inStream.pipe(readLine()).pipe(filterTransform);
  };

  return PropertyFilter;

})();


/* Static Methods / Factories */

PropertyFilter.withString = function(options) {
  var properties, string;
  string = options.string;
  properties = _.chain(options.string.split("\n")).map(function(line) {
    if (Property.isParseableString(line)) {
      return new Property(line, options);
    }
  }).filter(function(property) {
    return property;
  }).value();
  options = _.extend({}, options, {
    properties: properties
  });
  return new PropertyFilter(options);
};

PropertyFilter.withStream = function(options) {
  var done, inStream, properties;
  if (!(options && options.inStream)) {
    throw new ArgumentError('An input stream is required');
  }
  inStream = options.inStream;
  done = options.done;
  properties = [];
  return inStream.pipe(readLine()).on('data', function(line) {
    if (Property.isParseableString(line)) {
      return properties.push(new Property(line, options));
    }
  }).on('end', function() {
    options = _.extend({}, options, {
      properties: properties
    });
    return done && done(null, new PropertyFilter(options));
  }).on('error', function(e) {
    return done && done(e);
  });
};

PropertyFilter.getDefaultOptions = function() {
  return _.clone(DEFAULT_OPTIONS);
};

module.exports = PropertyFilter;
